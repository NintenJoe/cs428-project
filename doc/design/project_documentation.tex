%	@file FinalDocumentation.tex
%
%	@author Josh Halstead, Joe Ciurej
%	@date Spring 2014
%	
%   LaTeX source file for the design document for the CS428 project.  More 
%   information about the requirements for this documentation file can be found
%   here: "https://wiki.engr.illinois.edu/display/cs428sp14/Final+Documentation"

\documentclass{article}
\usepackage[parfill]{parskip}		% Package that improves paragraph formatting
\usepackage[pdftex]{graphicx}		% Package that faciliates figure insertion
\usepackage{float}					% Package that allows for arbitrary figure insertion
\usepackage{hyperref}				% Package that allows for text hyperlinking
\usepackage{tikz}					% Package that facilitates box rendering

% The following code block changes a few parameters of the page to make the
% text fill up more space on any given page.  For our liking, the default 'article'
% template is too sparse.
\addtolength{\voffset}{-2cm}
\addtolength{\textheight}{4cm}
\addtolength{\oddsidemargin}{-1.5cm}
\addtolength{\textwidth}{2cm}

% This command creates blue boxes around class names.
% @see "http://tex.stackexchange.com/questions/36401/drawing-boxes-around-words"
\newcommand{\classname}[1] {\texttt{#1} }
\newcommand{\methodname}[1] {\texttt{#1} }
\newcommand{\projectname}[0] {\texttt{Zol} }

\newcommand{\hreffsm}[1] {\href{http://en.wikipedia.org/wiki/Finite-state\_ machine}{#1}}
\newcommand{\hreftemplate}[1] {\href{http://en.wikipedia.org/wiki/Template\_ method\_ pattern}{#1}}
\newcommand{\hrefmvc}[1] {\href{http://en.wikipedia.org/wiki/Model\%E2\%80\%93view\%E2\%80\%93controller}{#1}}
\newcommand{\hrefloz}[0] {\href{http://en.wikipedia.org/wiki/The\_ Legend\_ of\_ Zelda\_ (video\_ game)}{The Legend of Zelda}}
\newcommand{\hrefxp}[0] {\href{http://www.extremeprogramming.org/}{Extreme Programming} }

\newcommand{\insertdiagram}[2]
{
	\begin{figure}[H]
		\centering
		\fbox{\includegraphics[height=#2]{figures/#1}}
		\caption{UML Diagram for the #1 Structure}
	\end{figure}
}

\begin{document}

	% Title Page %
	\title{Zol: Design Document}
	\author{Joshua Halstead and Joseph Ciurej \\
		University of Illinois: Urbana-Champaign (CS428)}
	\date{\today}
	\maketitle

	% Table of Contents %
	\tableofcontents
	\clearpage

	% Body %
	\section[Overview]{Brief Overview of \projectname}
	The primary motivation behind the initial conception and the continued
	development of the \projectname project was a desire among the members
	of the original development team to create a general and extensible game 
	engine that could be used to facilitate rapid game development and game
	prototyping.  That said, the objective of the \projectname project is 
	to provide game designers and developers with an intuitive and robust game 
	engine groundwork upon which they can quickly and easily develop video
	games with a wide variety of different rules and behaviors.

	While the project implementation has quite a way to go before it can be
	used to easily generate completely general games\footnote{See the 
	``Future Work'' section for more details}, the project in its current state 
	supports a great assortment of tools for creating varied two-dimensional 
	experiences.  In particular, \projectname provides the following utilities 
	for two-dimensional games:

	\begin{itemize}
		\item General game entity construction and specification using the 
		\hreffsm{finite state machine} behavior specification pattern.

		\item General and overridable collision detection and collision
		resolution infrastructures.

		\item Composite hitbox support with abstracted SVG specification and 
		arbitrary collision resolution behavior per hitbox.

		\item Animation support with specification via the commonly used
		\href{http://en.wikipedia.org/wiki/Sprite\_ (computer\_ graphics)#Sprites\_ by\_ CSS}
		{sprite sheet technique}.

		\item Tile-based game world construction and generation using adjustable 
		input image maps.

		\item Integrated support for in-game cameras with panning and easing
		functionality.

		\item Basic infrastructure for generalized game world rendering with 
		support for user interface widgets and overlays.
	\end{itemize}

	In order to demonstrate these capabilities, we've included the implementation
	of a basic game that mimics the classic title \hrefloz.  While this version
	isn't nearly as fully featured as the original, we believe that this demo game
	adequately demonstrates both the capabilities of our engine and how to properly
	utilize these capabilities.


	\section[Development]{\projectname Development Process}
	The development process followed by the development team while developing
	\projectname was a variant of the \hrefxp process (as it was presented in
	CS427: Software Engineering I) adapted for use in an academic setting.  
	The adaptions made (which are expounded upon in more explicit detail below) 
	were made primarily in order to better suit the development process to a group 
	developers with highly variate schedules and (consequently) limited availability 
	to meet.

		\subsection{Iterative Development}
		As far as iterative development is concerned, our process doesn't deviate
		much from its base Extreme Programming model.  Each development iteration
		spans two weeks, beginning with a planning game (involving the resolution 
		and refinement of user stories) and ending with an iteration product.

		In order to stress Extreme Programming's core principle of communication,
		our process also requires that each iteration contain four group meetings:
		two group requirement/review meetings (one at the beginning of each week
		to iron out requirements and design), one preparation meeting (the day 
		before the end of the iteration to polish the iteration product), and
		one presentation meeting (the final day of the iteration to demonstrate
		the product).

		\subsection{Refactoring}
		The process we used for the \projectname project is identical to Extreme
		Programming process with respect to its approach to refactoring, requiring 
		that development follow a test-code-refactor cycle and that code be 
		refactored whenever and wherever necessary.  This requirement led the
		development cycle of each team member during each iteration to adhere 
		to a schedule similar to the following:

		\begin{itemize}
			\item Refactor the implementation code associated with one's currently
			assigned task, updating test methods wherever necessary.

			\item Write the implementation and associated testing code to
			accomplish one's currently assigned task.

			\item Perform first-pass refactorings to the previously written code
			to improve its quality (time-permitting).
		\end{itemize}

		\subsection{Testing}
		While our process for \projectname values and upholds the core Extreme 
		Programming rules related to software testing, it includes one slight
		modification: \href{http://en.wikipedia.org/wiki/Test-driven\_ development}
		{test-driven development} practices are replaced with
		\href{http://treyhunner.com/2013/07/test-inspired-development/}
		{test-inspired development} practices.  Put another way, our process
		removes the requirement imposed by Extreme Programming for tests to be
		written before implementation code and instead allows developers to
		choose on a case-by-case basis on which segment of code should be
		written first.
		
		The primary reason that our process was adapted in this way was to
		reduce the volatility of testing code.  Many of us found that, unlike
		advocates of the test-first methodology claim, writing test code first
		doesn't adequately elucidate implementation design requirements, which
		often causes tests to be rewritten or overhauled after such requirements
		are discovered (often by means of writing the implementation code itself).
		As such, we adopted the more flexible approach of test-inspired
		development over test-first development to eliminate the amount of time
		wasted on this unecessay rehashing, which expedites project development
		in most cases.

		\subsection{Collaborative Development}
		Perhaps the most prominent deviation of our process from its Extreme
		Programming base is its replacement of the centralized code review
		technique \href{http://www.extremeprogramming.org/rules/pair.html}
		{pair-programming} with the distributed code review scheme afforded
		by \href{https://www.atlassian.com/git/workflows#!pull-request}
		{pull requests} and the \href{https://help.github.com/articles/using-pull-requests#shared-repository-model}
		{shared-repository model}.  This change shifts collaborative
		development to become asynchronous and spatially independent, supporting
		code reviews in a much more flexible and accessible way.

		While retaining the pair programming requirement in our process would
		have certainly been possible, it would have introduced a lot of
		scheduling overhead.  Since the pair programming technique assumes that 
		the members of each development pair have similar schedules, it's far
		too cumbersome to be useful in an academic project involving multiple,
		diverse student members (e.g. the \projectname project).  Hosting the
		reviews through a distributed version control system (i.e. GitHub) 
		eliminates this need for scheduling while retaining all the benefits 
		of code reviews, providing the optimal collaboration management solution.


	\section[Requirements]{\projectname Project Requirements}
	The requirements for the \projectname project can be found on 
	\href{https://github.com/NintenJoe/zol/wiki}{the project's main wiki page}.
	It's important to note that these requirements are directed towards a game
	designer client as opposed to a game player client.  As such, these
	requirements detail the required capabilities of general game engine that
	a designer may use to create a game (and not any particular game created
	through this means).  In contrast, the given use case document outlines 
	the potential user actions for the given \projectname example game.  This
	choice was made in order to cut down on the amount of abstraction and to
	present a more cohesive use case to potential designer users.

	The following is a listing of important requirement specification documents
	found on the main project wiki:

	\begin{itemize}
		\item \href{https://github.com/NintenJoe/zol/wiki#project-requirements-user-stories}{User Stories}
		\item \href{https://wiki.engr.illinois.edu/download/attachments/233410967/use-cases.pdf}{Use Cases}
	\end{itemize}


	\section[Architecture and Design]{Implementation Design and Architecture}
	At a high level, the \projectname game engine is an implementation of the
	\hrefmvc{model-view-controller design pattern} with the following components:

	\begin{description}
		\item[Model:] All the logic and data associated with the implementation
		of the underlying game world, including the logic for updating entities,
		loading new worlds, detecting entity collisions, resolving entity 
		collisions, etc.
		\item[View:] All the logic and data associated with the rendering and displaying
		of the contents of the underlying game world, including the logic for
		displaying world entities, displaying world tiles, and rendering user
		interface modules and overlays.
		\item[Controller:] All the logic and data associated with updating the
		model and view components based on user input.  In constrast to the
		previous two components, this component is quite sparse, encapsulating
		only the user key input capture and broadcast logic.
	\end{description}

	TODO: More description of the overall architecture here.

		\subsection[Primary Components]{Primary Implementation Components}
		The core of the \projectname project implementation consists of the 
		higher-level types used to implement the model and view components within
		the overall architecture.  For each of these primary components, the listing 
		below describes the major functionality encapsulated by that primary component 
		and provides a visual aid for its role in the \projectname architecture through a 
		\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

			\subsubsection[\classname{Event}]{The \classname{Event} Component}
			TODO

			\subsubsection[\classname{StateMachine}]{The \classname{StateMachine} Component}
			TODO

			\subsubsection[\classname{PhysicalState}]{The \classname{PhysicalState} Component}
			TODO

			\subsubsection[\classname{Entity}]{The \classname{Entity} Component}
			TODO

			\subsubsection[\classname{World}]{The \classname{World} Component}
			TODO

			\subsubsection[\classname{GameWorld}]{The \classname{GameWorld} Component}
			TODO

			\subsubsection[\classname{GameView}]{The \classname{GameView} Component}
			TODO

		\subsection{Framework/Library Integration}
		For the implementation of our project, we consciously avoided using any
		existing game development frameworks in order to maintain complete
		implementation freedom.  One of the primary goals of our project was
		to implement a generalized game engine, and using an existing game
		framework would only serve to complicate and limit this task.  Instead, 
		we decided to implement the entirety of our system without a framework, 
		only using supplementary libraries such as 
		\href{http://www.pygame.org/news.html}{pygame} to help with lower-level 
		operations (e.g. image loading, image rendering, etc.).  Thus, the
		\projectname project's design is completely independent of any existing 
		game framework's design/architecture.


	\section[Future Plans]{The Future of \projectname}
	During our initial development period, we found that we were not able to
	fully realize many of the features we wished to incorporate into the
	\projectname game engine.  The following section details the major additions
	we wish to integrate into the engine in the future as well as future plans 
	we have for the project.

		\subsection[Features]{Future Functions and Features}
		There were many features that we considered during the initial development 
		period that couldn't be fully implemented due to time constraints.  These
		features primarily involve improving the generality of the existing game
		engine, extending the basic functions provided by the game engine (e.g.
		adding to the list of provided state behaviors), and providing an enhanced
		user interface for specifying world entity behavior and game world 
		infrastructure.

		The following is a listing of all the most important features to be added
		to the \projectname project in the future:

		\begin{itemize}
			\item Creating a user interface to facilitate the full manipulation 
			of entity state machines.

			\item Creating a user interface to facilitate more user-friendly
			creation and manipulation of tile-based game worlds.

			\item Further generalization of the collision detection and collision
			resolution systems.

			\item Further generalization of the rendering engine to incorporate
			arbitrary user interface overlays and widgets.

			\item Adding support for arbitrary game state saving and loading.

			\item Adding support for hot-swap game loading to facilitate more
			rapid prototyping and game parameter adjustment.

			\item Expanding the functionality of the in-game camera utility to
			allow for behaviors such as zooming.

			\item Expanding of the in-game menu system to support more general
			menus with a wider variety of options.

			\item Restructuring the existing architecture to facilitate
			multi-threading (e.g. separate threads for the model-related and
			the view-related logic).
		\end{itemize}

		\subsection[Deployment]{Future Deployment Details}
		At the end of the initial development period, we plan to publish
		the \projectname project as a stand-alone application to a new
		GitHub project repository.  Once the project has been republished,
		the development process for the project will shift to a 
		\href{http://en.wikipedia.org/wiki/The\_ Cathedral\_ and\_ the\_ Bazaar}
		{Bazaar-based process} with Joe as the primary project manager
		and a new phase of development will begin.  During this phase and all
		future stages of development, the project repository will be made publicly
		available so that any existing team member or open-source contributor
		may help to expand the existing implementation into a more robust
		game engine.

		\subsection[Personal Reflections]{Team Reflections on the Project}
		The following section contains a brief overview of each team member's
		personal experience with the project, including their personal reflections
		on both the project's development (especially in terms of the development
		process) and on the final product.

		\begin{description}
			\item[Josh's Reflection] \hfill \\
			TODO

			\item[Andrew's Reflection] \hfill \\
			TODO

			\item[Nick's Reflection] \hfill \\
			I think that the development process we used for this project was
			really swell. We made excellent use of branches in Git to work through
			our assigned tasks without breaking things for other people working on
			their tasks, but while still being able to push things to Github for
			version control. We also had Travis for continuous integration, which
			helped avoid pushing broken code to master, and coveralls to help us
			know which classes needed better test coverage. Coveralls is by no means
			perfect though, since it only tracks whether lines were touched during
			testing, not whether they behave as intended, but it served as a very
			good heuristic that kept everyone writing good tests for their code.
			These factors contributed to a final product that I think is very stable
			and well tested.

			\item[Edwin's Reflection] \hfill \\
			I've been very passionate about video games for a long time and this 
			is the first time I've taken part in the creating side of it with a group of
			others. Overall I thoroughly enjoyed the entire experience and learned a lot
			about software development process. I also learned a lot about the the fun
			and pain of game development. The development process was very good
			and orderly in that I learned a lot about using a shared repository and all the
			goods it can bring as well as the headaches. The final product is something
			I am really proud of, if we had more time I wish we could have added 
			sound effects but other than that, it is something I am satisfied with.

			\item[Eric's Reflection] \hfill \\
			I like the development process that we used worked out pretty well,
			and it was a very good decision to switch to Git for version control. I
			am pretty satisfied with how our end result came out, because its 
			a very well structured game engine that can be repurposed for multiple
			games. It took more time to have a game to show for it, but it was a 
			good decision overall.

			\item[Joe's Reflection] \hfill \\
			Overall, I'd say that I'm quite pleased with the outcome of this
			project.  While there were certainly a few high points and low points
			during development, I'm happy with the experience overall because it
			taught me a lot about collaborative software development and game 
			development technologies.  
			
			In particular, I learned that the shared repository model is extremely 
			effective in facilitating distributed collaborative development and 
			that test-inspired development serves as a great testing technique 
			alternative to test-driven development when dealing with unfamiliar 
			designs and technologies.  Additionally, I thought that the adapted 
			development process that our group used for this project worked really 
			well, and I hope that I can utilize similar processes effectively 
			in my future projects.  		
	\end{description}

\end{document}
